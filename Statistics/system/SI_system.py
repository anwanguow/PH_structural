#!/usr/bin/env python3# -*- coding: utf-8 -*-import osimport numpy as npimport pandas as pdfrom scipy.stats import entropyimport matplotlib.pyplot as pltimport seaborn as snsimport logginglogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')def compute_persistent_homology_features(barcode_data):    stats = []    label = barcode_data['label']    for dim in ['H0', 'H1', 'H2']:        diagrams = barcode_data[dim]        if len(diagrams) == 0:            continue        lengths = diagrams[:, 1] - diagrams[:, 0]        lengths = lengths[np.isfinite(lengths)]        stats.append({            "dimension": dim,            "num_barcodes": len(lengths),            "max_length": np.max(lengths),            "mean_length": np.mean(lengths),            "persistent_entropy": entropy(lengths / np.sum(lengths)),            "max_birth": np.max(diagrams[:, 0]),            "mean_death": np.mean(diagrams[:, 1][np.isfinite(diagrams[:, 1])]),            "lifetime": lengths,            "label": label,            "birth_times": diagrams[:, 0],            "death_times": diagrams[:, 1]        })    return statsbarcode_dir = "barcodes"all_features = []for barcode_file in os.listdir(barcode_dir):    if barcode_file.endswith(".npy"):        barcode_data = np.load(os.path.join(barcode_dir, barcode_file), allow_pickle=True).item()        features = compute_persistent_homology_features(barcode_data)        all_features.extend(features)features_df = pd.DataFrame(all_features)label_map = {0: 'liquid', 1: 'crystal', 2: 'amorphous'}features_df['label_name'] = features_df['label'].map(label_map)def calculate_separation_index_per_sample(row):    if row['dimension'] == 'H1':        h1_persistence = row['death_times'] - row['birth_times']        mean_h1 = np.mean(h1_persistence)        std_h1 = np.std(h1_persistence)        return mean_h1, std_h1    elif row['dimension'] == 'H2':        h2_persistence = row['death_times'] - row['birth_times']        mean_h2 = np.mean(h2_persistence)        std_h2 = np.std(h2_persistence)        return mean_h2, std_h2    return None, Noneseparation_indices = []for idx, row in features_df.iterrows():    if row['dimension'] == 'H1':        mean_h1, std_h1 = calculate_separation_index_per_sample(row)        next_row = features_df.iloc[idx + 1]        if next_row['dimension'] == 'H2':            mean_h2, std_h2 = calculate_separation_index_per_sample(next_row)            if mean_h1 is not None and mean_h2 is not None:                separation_index = np.abs(mean_h1 - mean_h2) / (std_h1 + std_h2)                separation_indices.append({                    'label': row['label'],                    'label_name': row['label_name'],                    'separation_index': separation_index                })separation_df = pd.DataFrame(separation_indices)plt.figure(figsize=(6, 6), dpi=300)sns.boxplot(    x='label_name', y='separation_index', data=separation_df,     palette={'liquid': '#ADD8E6', 'crystal': '#006400', 'amorphous': '#FFD700'},    linewidth=2.5)plt.xlabel('Class', fontsize=20)plt.ylabel('Separation Index', fontsize=20)plt.xticks(fontsize=20)plt.yticks([0, 0.3, 0.6, 0.9, 1.2, 1.5, 1.8], fontsize=20)plt.tight_layout()plt.savefig('SI_system.png', bbox_inches='tight', dpi=300)plt.show()logging.info("Separation index boxplot saved to SI_system.png.")